C:\Anaconda2\python.exe C:/Users/jd/PycharmProjects/mokuai/model.py
Help on class SQLAlchemy in module flask_sqlalchemy:

class SQLAlchemy(__builtin__.object)
 |  This class is used to control the SQLAlchemy integration to one
 |  or more Flask applications.  Depending on how you initialize the
 |  object it is usable right away or will attach as needed to a
 |  Flask application.
 |
 |  There are two usage modes which work very similarly.  One is binding
 |  the instance to a very specific Flask application::
 |
 |      app = Flask(__name__)
 |      db = SQLAlchemy(app)
 |
 |  The second possibility is to create the object once and configure the
 |  application later to support it::
 |
 |      db = SQLAlchemy()
 |
 |      def create_app():
 |          app = Flask(__name__)
 |          db.init_app(app)
 |          return app
 |
 |  The difference between the two is that in the first case methods like
 |  :meth:`create_all` and :meth:`drop_all` will work all the time but in
 |  the second case a :meth:`flask.Flask.app_context` has to exist.
 |
 |  By default Flask-SQLAlchemy will apply some backend-specific settings
 |  to improve your experience with them.  As of SQLAlchemy 0.6 SQLAlchemy
 |  will probe the library for native unicode support.  If it detects
 |  unicode it will let the library handle that, otherwise do that itself.
 |  Sometimes this detection can fail in which case you might want to set
 |  `use_native_unicode` (or the ``SQLALCHEMY_NATIVE_UNICODE`` configuration
 |  key) to `False`.  Note that the configuration key overrides the
 |  value you pass to the constructor.
 |
 |  This class also provides access to all the SQLAlchemy functions and classes
 |  from the :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` modules.  So you can
 |  declare models like this::
 |
 |      class User(db.Model):
 |          username = db.Column(db.String(80), unique=True)
 |          pw_hash = db.Column(db.String(80))
 |
 |  You can still use :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` directly, but
 |  note that Flask-SQLAlchemy customizations are available only through an
 |  instance of this :class:`SQLAlchemy` class.  Query classes default to
 |  :class:`BaseQuery` for `db.Query`, `db.Model.query_class`, and the default
 |  query_class for `db.relationship` and `db.backref`.  If you use these
 |  interfaces through :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` directly,
 |  the default query class will be that of :mod:`sqlalchemy`.
 |
 |  .. admonition:: Check types carefully
 |
 |     Don't perform type or `isinstance` checks against `db.Table`, which
 |     emulates `Table` behavior but is not a class. `db.Table` exposes the
 |     `Table` interface, but is a function which allows omission of metadata.
 |
 |  You may also define your own SessionExtension instances as well when
 |  defining your SQLAlchemy class instance. You may pass your custom instances
 |  to the `session_extensions` keyword. This can be either a single
 |  SessionExtension instance, or a list of SessionExtension instances. In the
 |  following use case we use the VersionedListener from the SQLAlchemy
 |  versioning examples.::
 |
 |      from history_meta import VersionedMeta, VersionedListener
 |
 |      app = Flask(__name__)
 |      db = SQLAlchemy(app, session_extensions=[VersionedListener()])
 |
 |      class User(db.Model):
 |          __metaclass__ = VersionedMeta
 |          username = db.Column(db.String(80), unique=True)
 |          pw_hash = db.Column(db.String(80))
 |
 |  The `session_options` parameter can be used to override session
 |  options.  If provided it's a dict of parameters passed to the
 |  session's constructor.
 |
 |  .. versionadded:: 0.10
 |     The `session_options` parameter was added.
 |
 |  .. versionadded:: 0.16
 |     `scopefunc` is now accepted on `session_options`. It allows specifying
 |      a custom function which will define the SQLAlchemy session's scoping.
 |
 |  .. versionadded:: 2.1
 |     The `metadata` parameter was added. This allows for setting custom
 |     naming conventions among other, non-trivial things.
 |
 |  Methods defined here:
 |
 |  __init__(self, app=None, use_native_unicode=True, session_options=None, metadata=None)
 |
 |  __repr__(self)
 |
 |  apply_driver_hacks(self, app, info, options)
 |      This method is called before engine creation and used to inject
 |      driver specific hacks into the options.  The `options` parameter is
 |      a dictionary of keyword arguments that will then be used to call
 |      the :func:`sqlalchemy.create_engine` function.
 |
 |      The default implementation provides some saner defaults for things
 |      like pool sizes for MySQL and sqlite.  Also it injects the setting of
 |      `SQLALCHEMY_NATIVE_UNICODE`.
 |
 |  apply_pool_defaults(self, app, options)
 |
 |  create_all(self, bind='__all__', app=None)
 |      Creates all tables.
 |
 |      .. versionchanged:: 0.12
 |         Parameters were added
 |
 |  create_scoped_session(self, options=None)
 |      Helper factory method that creates a scoped session.  It
 |      internally calls :meth:`create_session`.
 |
 |  create_session(self, options)
 |      Creates the session.  The default implementation returns a
 |      :class:`SignallingSession`.
 |
 |      .. versionadded:: 2.0
 |
 |  drop_all(self, bind='__all__', app=None)
 |      Drops all tables.
 |
 |      .. versionchanged:: 0.12
 |         Parameters were added
 |
 |  get_app(self, reference_app=None)
 |      Helper method that implements the logic to look up an application.
 |
 |  get_binds(self, app=None)
 |      Returns a dictionary with a table->engine mapping.
 |
 |      This is suitable for use of sessionmaker(binds=db.get_binds(app)).
 |
 |  get_engine(self, app, bind=None)
 |      Returns a specific engine.
 |
 |      .. versionadded:: 0.12
 |
 |  get_tables_for_bind(self, bind=None)
 |      Returns a list of all tables relevant for a bind.
 |
 |  init_app(self, app)
 |      This callback can be used to initialize an application for the
 |      use with this database setup.  Never use a database in the context
 |      of an application not initialized that way or connections will
 |      leak.
 |
 |  make_connector(self, app, bind=None)
 |      Creates the connector for a given state and bind.
 |
 |  make_declarative_base(self, metadata=None)
 |      Creates the declarative base.
 |
 |  reflect(self, bind='__all__', app=None)
 |      Reflects tables from the database.
 |
 |      .. versionchanged:: 0.12
 |         Parameters were added
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  engine
 |      Gives access to the engine.  If the database configuration is bound
 |      to a specific application (initialized with an application) this will
 |      always return a database connection.  If however the current application
 |      is used this might raise a :exc:`RuntimeError` if no application is
 |      active at the moment.
 |
 |  metadata
 |      Returns the metadata


Process finished with exit code 0